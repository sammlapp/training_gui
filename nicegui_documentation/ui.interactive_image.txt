ui.interactive_image

Interactive Image
Create an image with an SVG overlay that handles mouse events and yields image coordinates. It is also the best choice for non-flickering image updates. If the source URL changes faster than images can be loaded by the browser, some images are simply skipped. Thereby repeatedly updating the image source will automatically adapt to the available bandwidth. See OpenCV Webcam for an example.

The mouse event handler is called with mouse event arguments containing

type (the name of the JavaScript event),
image_x and image_y (image coordinates in pixels),
button and buttons (mouse button numbers from the JavaScript event), as well as
alt, ctrl, meta, and shift (modifier keys from the JavaScript event).
You can also pass a tuple of width and height instead of an image source. This will create an empty image with the given size.

source:	the source of the image; can be an URL, local file path, a base64 string or just an image size
content:	SVG content which should be overlaid; viewport has the same dimensions as the image
size:	size of the image (width, height) in pixels; only used if source is not set
on_mouse:	callback for mouse events (contains image coordinates image_x and image_y in pixels)
events:	list of JavaScript events to subscribe to (default: ['click'])
cross:	whether to show crosshairs or a color string (default: False)
main.py
from nicegui import events, ui

def mouse_handler(e: events.MouseEventArguments):
    color = 'SkyBlue' if e.type == 'mousedown' else 'SteelBlue'
    ii.content += f'<circle cx="{e.image_x}" cy="{e.image_y}" r="15" fill="none" stroke="{color}" stroke-width="4" />'
    ui.notify(f'{e.type} at ({e.image_x:.1f}, {e.image_y:.1f})')

src = 'https://picsum.photos/id/565/640/360'
ii = ui.interactive_image(src, on_mouse=mouse_handler, events=['mousedown', 'mouseup'], cross=True)

ui.run()
NiceGUI

Adding layers
In some cases you might want to add different groups of SVG elements to an image. Maybe there is one element that needs frequent updates, while the other elements are rarely changed. Putting all elements in the same SVG can lead to performance issues, because the whole SVG needs to be sent to the client whenever one of the elements changes.

The solution is to add multiple layers to the image. Each layer is a separate SVG element, which means that each layer can be updated independently.

The following demo shows this concept in action, even though both layers are changed at the same time.

Added in version 2.17.0

main.py
from nicegui import events, ui

def mouse_handler(e: events.MouseEventArguments):
    image.content += f'<circle cx="{e.image_x}" cy="{e.image_y}" r="30" fill="none" stroke="red" stroke-width="4" />'
    highlight.content = f'<circle cx="{e.image_x}" cy="{e.image_y}" r="28" fill="yellow" opacity="0.5" />'

src = 'https://picsum.photos/id/674/640/360'
image = ui.interactive_image(src, on_mouse=mouse_handler, cross=True)
highlight = image.add_layer()

ui.run()
NiceGUI

Nesting elements
You can nest elements inside an interactive image. Use Tailwind classes like "absolute top-0 left-0" to position the label absolutely with respect to the image. Of course this can be done with plain CSS as well.

main.py
from nicegui import ui

with ui.interactive_image('https://picsum.photos/id/147/640/360'):
    ui.button(on_click=lambda: ui.notify('thumbs up'), icon='thumb_up') \
        .props('flat fab color=white') \
        .classes('absolute bottom-0 left-0 m-2')

ui.run()
NiceGUI

Force reload
You can force an image to reload by calling the force_reload method. It will append a timestamp to the image URL, which will make the browser reload the image.

main.py
from nicegui import ui

img = ui.interactive_image('https://picsum.photos/640/360').classes('w-64')

ui.button('Force reload', on_click=img.force_reload)

ui.run()
NiceGUI

Blank canvas
You can also create a blank canvas with a given size. This is useful if you want to draw something without loading a background image.

main.py
from nicegui import ui

ui.interactive_image(
    size=(800, 600), cross=True,
    on_mouse=lambda e: e.sender.set_content(f'''
        <circle cx="{e.image_x}" cy="{e.image_y}" r="50" fill="orange" />
    '''),
).classes('w-64 bg-blue-50')

ui.run()
NiceGUI

Loaded event
You can listen to the "loaded" event to know when the image has been loaded.

main.py
import time
from nicegui import ui

ii = ui.interactive_image('https://picsum.photos/640/360')
ii.on('loaded', lambda e: ui.notify(f'loaded {e.args}'))
ui.button('Change Source', on_click=lambda: ii.set_source(f'https://picsum.photos/640/360?time={time.time()}'))

ui.run()
NiceGUI

Crosshairs
You can show crosshairs by passing cross=True. You can also change the color of the crosshairs by passing a color string.

Since version 2.4.0: You can use the add_slot method to add a custom "cross" slot with your own SVG template. The props.x and props.y variables will be available in the template, representing the crosshair position.

main.py
from nicegui import ui

ui.interactive_image('https://picsum.photos/id/565/640/360', cross='red')

ui.interactive_image('https://picsum.photos/id/565/640/360').add_slot('cross', '''
    <circle :cx="props.x" :cy="props.y" r="30" stroke="red" fill="none" />
    <line :x1="props.x - 30" :y1="props.y" :x2="props.x + 30" :y2="props.y" stroke="red" />
    <line :x1="props.x" :y1="props.y - 30" :x2="props.x" :y2="props.y + 30" stroke="red" />
''')

ui.run()
NiceGUI


SVG events
You can subscribe to events of the SVG elements by using the on method with an "svg:" prefix. Make sure to set pointer-events="all" for the SVG elements you want to receive events from.

Currently the following SVG events are supported:

pointermove
pointerdown
pointerup
pointerover
pointerout
pointerenter
pointerleave
pointercancel
main.py
from nicegui import ui

ui.interactive_image('https://picsum.photos/id/565/640/360', cross=True, content='''
    <rect id="A" x="85" y="70" width="80" height="60" fill="none" stroke="red" pointer-events="all" cursor="pointer" />
    <rect id="B" x="180" y="70" width="80" height="60" fill="none" stroke="red" pointer-events="all" cursor="pointer" />
''').on('svg:pointerdown', lambda e: ui.notify(f'SVG clicked: {e.args}'))

ui.run()
NiceGUI

Reference
Initializer
source:	the source of the image; can be an URL, local file path, a base64 string or just an image size
content:	SVG content which should be overlaid; viewport has the same dimensions as the image
size:	size of the image (width, height) in pixels; only used if source is not set
on_mouse:	callback for mouse events (contains image coordinates image_x and image_y in pixels)
events:	list of JavaScript events to subscribe to (default: ['click'])
cross:	whether to show crosshairs or a color string (default: False)
Properties
classes: 'Classes[Self]'

The classes of the element.

client: 'Client'

The client this element belongs to.

content: BindableProperty

html_id: 'str'

The ID of the element in the HTML DOM.

Added in version 2.16.0

is_deleted: 'bool'

Whether the element has been deleted.

is_ignoring_events: 'bool'

Return whether the element is currently ignoring events.

parent_slot: 'Slot | None' (settable)

The parent slot of the element.

props: 'Props[Self]'

The props of the element.

source: BindableProperty

style: 'Style[Self]'

The style of the element.

visible: BindableProperty

Methods
add_dynamic_resource(name: str, function: Callable) -> None

Add a dynamic resource to the element which returns the result of a function.

param name:	name of the resource
param function:	function that returns the resource response
add_layer(content: str = '') -> InteractiveImageLayer

Add a new layer with its own content.

Added in version 2.17.0

add_resource(path: str | Path) -> None

Add a resource to the element.

param path:	path to the resource (e.g. folder with CSS and JavaScript files)
add_slot(name: str, template: str | None = None) -> Slot

Add a slot to the element.

NiceGUI is using the slot concept from Vue: Elements can have multiple slots, each possibly with a number of children. Most elements only have one slot, e.g. a ui.card (QCard) only has a default slot. But more complex elements like ui.table (QTable) can have more slots like "header", "body" and so on. If you nest NiceGUI elements via with ui.row(): ... you place new elements inside of the row's default slot. But if you use with table.add_slot(...): ..., you enter a different slot.

The slot stack helps NiceGUI to keep track of which slot is currently used for new elements. The parent field holds a reference to its element. Whenever an element is entered via a with expression, its default slot is automatically entered as well.

param name:	name of the slot
param template:	Vue template of the slot
return:	the slot
ancestors(include_self: bool = False) -> Iterator[Element]

Iterate over the ancestors of the element.

param include_self:
 	whether to include the element itself in the iteration
bind_content(target_object: Any, target_name: str = 'content', forward: Optional[Callable[[Any], Any]] = None, backward: Optional[Callable[[Any], Any]] = None, strict: Optional[bool] = None) -> Self

Bind the content of this element to the target object's target_name property.

The binding works both ways, from this element to the target and from the target to this element. The update happens immediately and whenever a value changes. The backward binding takes precedence for the initial synchronization.

param target_object:
 	The object to bind to.
param target_name:
 	The name of the property to bind to.
param forward:	A function to apply to the value before applying it to the target (default: identity).
param backward:	A function to apply to the value before applying it to this element (default: identity).
param strict:	Whether to check (and raise) if the target object has the specified property (default: None, performs a check if the object is not a dictionary, added in version 3.0.0).
bind_content_from(target_object: Any, target_name: str = 'content', backward: Optional[Callable[[Any], Any]] = None, strict: Optional[bool] = None) -> Self

Bind the content of this element from the target object's target_name property.

The binding works one way only, from the target to this element. The update happens immediately and whenever a value changes.

param target_object:
 	The object to bind from.
param target_name:
 	The name of the property to bind from.
param backward:	A function to apply to the value before applying it to this element (default: identity).
param strict:	Whether to check (and raise) if the target object has the specified property (default: None, performs a check if the object is not a dictionary, added in version 3.0.0).
bind_content_to(target_object: Any, target_name: str = 'content', forward: Optional[Callable[[Any], Any]] = None, strict: Optional[bool] = None) -> Self

Bind the content of this element to the target object's target_name property.

The binding works one way only, from this element to the target. The update happens immediately and whenever a value changes.

param target_object:
 	The object to bind to.
param target_name:
 	The name of the property to bind to.
param forward:	A function to apply to the value before applying it to the target (default: identity).
param strict:	Whether to check (and raise) if the target object has the specified property (default: None, performs a check if the object is not a dictionary, added in version 3.0.0).
bind_source(target_object: Any, target_name: str = 'source', forward: Optional[Callable[[Any], Any]] = None, backward: Optional[Callable[[Any], Any]] = None, strict: Optional[bool] = None) -> Self

Bind the source of this element to the target object's target_name property.

The binding works both ways, from this element to the target and from the target to this element. The update happens immediately and whenever a value changes. The backward binding takes precedence for the initial synchronization.

param target_object:
 	The object to bind to.
param target_name:
 	The name of the property to bind to.
param forward:	A function to apply to the value before applying it to the target (default: identity).
param backward:	A function to apply to the value before applying it to this element (default: identity).
param strict:	Whether to check (and raise) if the target object has the specified property (default: None, performs a check if the object is not a dictionary, added in version 3.0.0).
bind_source_from(target_object: Any, target_name: str = 'source', backward: Optional[Callable[[Any], Any]] = None, strict: Optional[bool] = None) -> Self

Bind the source of this element from the target object's target_name property.

The binding works one way only, from the target to this element. The update happens immediately and whenever a value changes.

param target_object:
 	The object to bind from.
param target_name:
 	The name of the property to bind from.
param backward:	A function to apply to the value before applying it to this element (default: identity).
param strict:	Whether to check (and raise) if the target object has the specified property (default: None, performs a check if the object is not a dictionary, added in version 3.0.0).
bind_source_to(target_object: Any, target_name: str = 'source', forward: Optional[Callable[[Any], Any]] = None, strict: Optional[bool] = None) -> Self

Bind the source of this element to the target object's target_name property.

The binding works one way only, from this element to the target. The update happens immediately and whenever a value changes.

param target_object:
 	The object to bind to.
param target_name:
 	The name of the property to bind to.
param forward:	A function to apply to the value before applying it to the target (default: identity).
param strict:	Whether to check (and raise) if the target object has the specified property (default: None, performs a check if the object is not a dictionary, added in version 3.0.0).
bind_visibility(target_object: Any, target_name: str = 'visible', forward: Callable[[Any], Any] | None = None, backward: Callable[[Any], Any] | None = None, value: Any = None, strict: bool | None = None) -> Self

Bind the visibility of this element to the target object's target_name property.

The binding works both ways, from this element to the target and from the target to this element. The update happens immediately and whenever a value changes. The backward binding takes precedence for the initial synchronization.

param target_object:
 	The object to bind to.
param target_name:
 	The name of the property to bind to.
param forward:	A function to apply to the value before applying it to the target (default: identity).
param backward:	A function to apply to the value before applying it to this element (default: identity).
param value:	If specified, the element will be visible only when the target value is equal to this value.
param strict:	Whether to check (and raise) if the target object has the specified property (default: None, performs a check if the object is not a dictionary, added in version 3.0.0).
bind_visibility_from(target_object: Any, target_name: str = 'visible', backward: Callable[[Any], Any] | None = None, value: Any = None, strict: bool | None = None) -> Self

Bind the visibility of this element from the target object's target_name property.

The binding works one way only, from the target to this element. The update happens immediately and whenever a value changes.

param target_object:
 	The object to bind from.
param target_name:
 	The name of the property to bind from.
param backward:	A function to apply to the value before applying it to this element (default: identity).
param value:	If specified, the element will be visible only when the target value is equal to this value.
param strict:	Whether to check (and raise) if the target object has the specified property (default: None, performs a check if the object is not a dictionary, added in version 3.0.0).
bind_visibility_to(target_object: Any, target_name: str = 'visible', forward: Callable[[Any], Any] | None = None, strict: bool | None = None) -> Self

Bind the visibility of this element to the target object's target_name property.

The binding works one way only, from this element to the target. The update happens immediately and whenever a value changes.

param target_object:
 	The object to bind to.
param target_name:
 	The name of the property to bind to.
param forward:	A function to apply to the value before applying it to the target (default: identity).
param strict:	Whether to check (and raise) if the target object has the specified property (default: None, performs a check if the object is not a dictionary, added in version 3.0.0).
clear() -> None

Remove all child elements.

default_classes(add: str | None = None, remove: str | None = None, toggle: str | None = None, replace: str | None = None) -> type[Self]

Apply, remove, toggle, or replace default HTML classes.

This allows modifying the look of the element or its layout using Tailwind or Quasar classes.

Removing or replacing classes can be helpful if predefined classes are not desired. All elements of this class will share these HTML classes. These must be defined before element instantiation.

param add:	whitespace-delimited string of classes
param remove:	whitespace-delimited string of classes to remove from the element
param toggle:	whitespace-delimited string of classes to toggle (added in version 2.7.0)
param replace:	whitespace-delimited string of classes to use instead of existing ones
default_props(add: str | None = None, remove: str | None = None) -> type[Self]

Add or remove default props.

This allows modifying the look of the element or its layout using Quasar props. Since props are simply applied as HTML attributes, they can be used with any HTML element. All elements of this class will share these props. These must be defined before element instantiation.

Boolean properties are assumed True if no value is specified.

param add:	whitespace-delimited list of either boolean values or key=value pair to add
param remove:	whitespace-delimited list of property keys to remove
default_style(add: str | None = None, remove: str | None = None, replace: str | None = None) -> type[Self]

Apply, remove, or replace default CSS definitions.

Removing or replacing styles can be helpful if the predefined style is not desired. All elements of this class will share these CSS definitions. These must be defined before element instantiation.

param add:	semicolon-separated list of styles to add to the element
param remove:	semicolon-separated list of styles to remove from the element
param replace:	semicolon-separated list of styles to use instead of existing ones
delete() -> None

Delete the element and all its children.

descendants(include_self: bool = False) -> Iterator[Element]

Iterate over the descendants of the element.

param include_self:
 	whether to include the element itself in the iteration
force_reload() -> None

Force the image to reload from the source.

get_computed_prop(prop_name: str, timeout: float = 1) -> AwaitableResponse

Return a computed property.

This function should be awaited so that the computed property is properly returned.

param prop_name:
 	name of the computed prop
param timeout:	maximum time to wait for a response (default: 1 second)
mark(*markers: str) -> Self

Replace markers of the element.

Markers are used to identify elements for querying with ElementFilter which is heavily used in testing but can also be used to reduce the number of global variables or passing around dependencies.

param markers:	list of strings or single string with whitespace-delimited markers; replaces existing markers
move(target_container: Element | None = None, target_index: int = -1, target_slot: str | None = None) -> None

Move the element to another container.

param target_container:
 	container to move the element to (default: the parent container)
param target_index:
 	index within the target slot (default: append to the end)
param target_slot:
 	slot within the target container (default: default slot)
on(type: str, handler: events.Handler[events.GenericEventArguments] | None = None, args: None | Sequence[str] | Sequence[Sequence[str] | None] = None, throttle: float = 0.0, leading_events: bool = True, trailing_events: bool = True, js_handler: str = '(...args) => emit(...args)') -> Self

Subscribe to an event.

The event handler can be a Python function, a JavaScript function or a combination of both:

If you want to handle the event on the server with all (serializable) event arguments, use a Python handler.
If you want to handle the event on the client side without emitting anything to the server, use js_handler with a JavaScript function handling the event.
If you want to handle the event on the server with a subset or transformed version of the event arguments, use js_handler with a JavaScript function emitting the transformed arguments using emit(), and use a Python handler to handle these arguments on the server side. The js_handler can also decide to selectively emit arguments to the server, in which case the Python handler will not always be called.
Note that the arguments throttle, leading_events, and trailing_events are only relevant when emitting events to the server.

Updated in version 2.18.0: Both handlers can be specified at the same time.

param type:	name of the event (e.g. "click", "mousedown", or "update:model-value")
param handler:	callback that is called upon occurrence of the event
param args:	arguments included in the event message sent to the event handler (default: None meaning all)
param throttle:	minimum time (in seconds) between event occurrences (default: 0.0)
param leading_events:
 	whether to trigger the event handler immediately upon the first event occurrence (default: True)
param trailing_events:
 	whether to trigger the event handler after the last event occurrence (default: True)
param js_handler:
 	JavaScript function that is handling the event on the client (default: "(...args) => emit(...args)")
on_mouse(on_mouse: Handler[MouseEventArguments]) -> Self

Add a callback to be invoked when a mouse event occurs.

remove(element: Element | int) -> None

Remove a child element.

param element:	either the element instance or its ID
run_method(name: str, *args: Any, timeout: float = 1) -> AwaitableResponse

Run a method on the client side.

If the function is awaited, the result of the method call is returned. Otherwise, the method is executed without waiting for a response.

param name:	name of the method
param args:	arguments to pass to the method
param timeout:	maximum time to wait for a response (default: 1 second)
set_content(content: str) -> None

Set the content of this element.

param content:	The new content.
set_source(source: str | Path | PIL_Image) -> None

set_visibility(visible: bool) -> None

Set the visibility of this element.

param visible:	Whether the element should be visible.
tooltip(text: str) -> Self

Add a tooltip to the element.

param text:	text of the tooltip
update() -> None

Update the element on the client side.

Inheritance
SourceElement
ContentElement
Element
Visibility